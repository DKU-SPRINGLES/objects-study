# 메시지와 인터페이스

> 이번 장에서는 인터페이스가 객체의 품질에 어떤 영향을 미치는지 알아본다.

## 협력과 메시지

- 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다.
- 따라서 객체가 수신하는 메시지의 집합과 객체가 외부에게 전송하는 메시지의 집합으로 구별할 수 있다.

### 용어 정리

- 메시지
  - 객체가 다른 객체와 협력하기 위해 사용하는 의사소통 매커니즘.
  - 전송자와 수신자 **양쪽 모두**를 포함하는 개념.
- 오퍼레이션
  - 객체가 다른 객체에게 제공하는 **추상적인** 서비스.
  - 쉽게 말하면 퍼블릭 **인터페이스에 포함된 메시지**다.
  - 오직 메시지 **수신자**의 관점.
  - 메시지 수신이란 메시지에 대응되는 객체의 오퍼레이션을 호출하는 것.
- 메서드
  - 메시지에 응답하기 위해 실행되는 코드 블록.
  - **오퍼레이션의 구현**이다.
  - 동일한 오퍼레이션이라도 메서드가 다를 수 있다.
- 시그니처
  - 오퍼레이션이나 메서드의 **명세**
  - 기본적으로 이름과 인자 목록을 포함하고, 언어에 따라서 반환 타입을 포함하기도 한다.

## 인터페이스와 설계 품질

- 좋은 인터페이스는
  - **최소한**의 인터페이스
  - **추상적인** 인터페이스

- 좋은 인터페이스를 얻기 위해서는
  - 디미터 법칙
  - 묻지 말고 시켜라.
  - 의도를 드러내는 인터페이스
  - 명령-쿼리 분리

### 디미터 법칙

- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것.
  - "낯선 자에게 말하지 말라."
  - "인접한 이웃하고만 말하라."
  - "오직 하나의 도트만 사용하라."
- 아래 조건을 만족하는 인스턴스에만 메시지를 전송하면 된다.
  - this 객체
  - 메서드의 매개변수
  - this의 속성
  - this의 속성인 컬렉션의 요소
  - 메서드 내에서 생성된 지역 객체
- 기차 충돌
  - `screening.getMovie().getDiscountConditions();`
  - 두 개 이상의 도트를 사용하면서 연쇄적으로 메시지를 전송하는 상황이다.
  - 이로서 클래스의 내부 구현이 외부로 노출되어 캡슐화가 무너지고, 메시지 전송자와 수신자가 강하게 결합된다.

### 묻지 말고 시켜라

- 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다.
- 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.
- **상태**를 묻는 오퍼레이션을 **행동**을 요청하는 오퍼레이션으로 대체해라.

### 의도를 드러내는 인터페이스

- 메서드는 **"어떻게"** 하는지가 아니라 **"무엇을"** 하는지를 드러내야 한다.
  - (나쁜 예) `isSatisfiedByPeriod`, `isSatisfiedBySequence`
  - (좋은 예) `isSatisfiedBy`
- 하나의 구현을 가진 메시지의 이름을 잘 짓는 방법
  - 매우 다른 두 번째 구현을 상상하라.
  - 해당 메서드에 동일한 이름을 붙인다고 상상하라.
  - 아마도 이 순간 스스로가 생각할 수 있는 가장 추상적인 이름을 메서드에 붙일 것이다.

## 원칙의 함정

- 설계는 트레이드오프의 산물이다.
  - 원칙이 현재 상황에 부적합핟고 **판단된다면 과감하게 원칙을 무시하라.**
  - 원칙이 언제 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 길러야 한다.
  - 소프트웨어 설계에서 변하지 않는 법칙은 "경우에 따라 다르다" 이다.

## 명령-쿼리 분리 원칙

### 용어 정리

- 프로시저 (명령)
  - 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
  - ex) `setter`
- 함수 (쿼리)
  - 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
  - ex) `getter`
- 참조 투명성
  - 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는다.
  - 장점
    - 식을 쉽게 계산할 수 있다.
    - 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.

### 원칙

- 객체의 상태를 변경하는 **명령**은 반환값을 가질 수 없다.
- 객체의 정보를 반환하는 **쿼리**는 상태를 변경할 수 없다.

### 명령형 프로그래밍과 함수형 프로그래밍

- 부수효과를 기반으로 하는 프로그래밍 방식을 **명령형 프로그래밍** 이라고 부른다.
  - 대부분의 객체지향 프로그래밍 언어들은 메시지에 의해 객체의 상태 변경에 집중하기 때문에 명령형 프로그래밍 언어로 분류된다.
- **함수형 프로그래밍** 은 부수효과가 존재하지 않는 수학적인 함수에 기반한다.
  - 함수형 프로그래밍은 참조 투명성의 장점을 극대화 할 수 있다.
  - 프로그램의 실행 결과를 이해하고 예측하기에 용이하다.
  - 병렬 처리가 가능하다.
- 위와 같은 이유로 최근에는 다양한 객체지향 언어들이 함수형 프로그래밍 패러다임을 접목시키고 있다.
  - ex) java 8의 람다식.

## 느낀 점

 의도를 드러내는 인터페이스를 설계해야 한다는 구절을 읽고 나서야 강의에서 항상 얘기하던 "setter 사용을 지양해라." 라는 말의 뜻을 이해할 수 있었다. 강의에서는 항상 setter 대신 의미있는 메서드명을 사용하라고 했는데 결국 객체의 상태를 외부에 노출시키지 않고, 오직 메시지의 행동만을 표현할 수 있기 때문이었다. 메서드명을 추상화하는 것은 결국 메시지 수신자와 송신자 간의 결합을 느슨하게 유지할 수 있다.

 변수명을 고민한 적은 많아도 메서드명을 고민한 적은 별로 없다. 기본적으로 변수라는 명사에 동사를 더하는 방식으로 메서드명을 많이 작성하곤 했다. 하지만 이러한 방식은 결국 객체의 상태를 외부에 노출하는 꼴이다. 이러한 방식으로 설계했던 이유는 결국 인터페이스를 설계할 때부터 객체의 상태(구현)을 신경썼기 때문이라고 생각한다. 책임 주도 설계의 중요성을 다시 한 번 느낄 수 있었다.

 "객체지향"과 "함수형 프로그래밍" 용어만 들었을 때는 굉장히 좋아보이는 용어들이어서 무작정 적용해야겠다는 생각으로 사용했던 것 같다. 실제로 java8의 람다식과 스트림을 사용하면서 코드 가독성이 좋다는 것 이외의 장점은 생각해보지 못했었다. 하지만 참조 투명성이란 개념을 배우고 나서부터 람다식과 스트림이 부수 효과가 없는 함수를 제공함으로서 기존 변수의 불변성을 보장한다는 사실을 체득할 수 있었다.
