# [오브젝트] 14장 - 일관성 있는 협력

개발을 하다 보면 유사한 요구사항을 반복적으로 추가하거나 수정하게 되는 경우가 있다. 이때 객체들의 협력 구조가 제각각이면 코드를 이해하기 어렵고 버그가 발생할 위험성도 높아진다. 객체지향의 장점인 재사용을 위해서는 일관성 있는 협력이 필요하다. 일관성 있는 설계는 코드의 구조를 파악하기 쉽게 해준다.

## 일관적이지 않은 설계

반면 일관적이지 않은 설계(비일관성)는 다음 두 가지 상황에서 발목을 잡는다.

1. 새로운 구현을 추가해야 하는 상황
2. 기존의 구현을 이해해야 하는 상황

하나의 인터페이스를 구현하는데에 있어 서로 다른 세가지 구현방식이 존재한다면 새로운 구현을 추가하는 개발자의 입장에서는 어떤방식을 선택하든 문제는 없지만 일관성은 점점더 어긋나게 된다.

또한 서로 다른 구현방식은 기존의 코드를 이해하기 어렵게 한다. 대부분의 사람들은 유사한 요구사항을 구현하는 코드는 유사한 방식으로 구현될 것이라 예상하기 때문에 서로 다른 방식으로 구현되어 있다면 요구사항이 유사하다는 사실도 의심하게 된다.

**유사한 요구사항을 구현하는 서로 다른 구조의 코드는 코드를 이해하는 데 심리적인 장벽을 만든다.**

## 설계에 일관성 부여하기

일관성 있는 설계를 위해서는 다양한 설계경험을 익혀야 한다. 풍부한 설계경험은 어떤 변경이 중요한지, 변경을 어떻게 다뤄야 하는지에 대한 통찰력을 가지게 된다. 하지만 이러한 설계 경험을 단시간에 쌓아 올리는 것은 어렵다.

다행히도 이러한 경험 법칙을 모아놓은 디자인 패턴이라는 설계 템플릿이 있다. 디자인 패턴을 학습하면 빠른 시간 안에 전문가의 경험을 흡수할 수 있다. 하지만 모든 경우에 적합한 디자인 패턴을 찾을수 있는것은 아니기에 다음의 기본 지침을 따르는것이 도움이 된다.

**1. 변하는 개념을 변하지 않는 개념으로부터 분리하라**
**2. 변하는 개념을 캡슐화 하라**

핵심은 휼륭한 추상화를 찾아 추상화에 의존하도록 만드는 것이다. 추상화에 대한 의존은 결합도를 낮추고 대체 가능한 역할로 구성된 협력을 설계할 수 있게 해준다.

### 캡슐화 다시 살펴 보기

변경에 초점을 맞추고 캡슐화의 관점에서 설계를 바라보면 일관성 있는 협력 패턴을 얻을 수 있다.

캡슐화는 단순히 데이터를 감추는 것이 아니다. 소프트웨어 안에서 **변할 수 있는 모든 개념을 감추는 것**이다.

캡슐화의 가장 대표적인 예는 객체의 퍼블릭 인터페이스과 구현을 분리하는 것이다.  객체를 구현한 개발자는 필요할 때 객체의 내부 구현을 수정하길 원하고, 객체와 협력하는 클라이언트의 개발자는 객체의 인터페이스가 변하지 않기를 원한다. 따라서 자주 변경되는 내부 구현을 안정적인 퍼블릭 인터페이스 뒤로 숨겨야 한다.

**캡슐화의 종류**
- 데이터 캡슐화
    - 인스턴스 변수의 가시성을 private으로 하여 내부에서 관리하는 데이터를 캡슐화 한다.
- 메서드 캡슐화
    - 메서드의 접근 지정자를 통해 클래스 외부에 영향을 미치지 않고 메서드를 수정할 수 있다.
- 객체 캡슐화
    - 객체의 인스턴스 변수를 private 타입으로 캡슐화 할 수 있다. 합성을 의미한다.
- 서브타입 캡슐화
    - 상속을 통해 서브타입(자식클래스)의 종류를 캡슐화 할 수 있다. 다형성을 의미한다.

캡슐화란 단지 데이터 은닉을 의미하는 것이 아니다. 코드 수정으로 인한 파급효과를 제어할 수 있는 모든 기법이 캡슐화의 일종이다. 변경을 캡슐화 할 수 있는 다양한 방법이 존재하지만 협력을 일관성 있게 만들기 위해 가장 일반적으로 사용하는 방법은 서브타입 캡슐화(**상속**)와 객체 캡슐화(**합성**)를 조합하는 것이다.

**변하는 부분을 분리해서 타입 계층을 만든다.**
- 변하지 않는 부분으로 부터 변하는 부분을 분리한다.
- 변하는 부분들의 공통적인 행동을 추상 클래스나 인터페이스로 추상화 한 후 변하는 부분들이 추상클래스나, 인터페이스를 상속받게 만든다.

**변하지 않는 부분의 일부로 타입 계층을 합성한다**
- 변하지 않는 부분에서는 변경되는 구체적인 사항에 결합돼서는 안된다.
- 의존성 주입과 같이 결합도를 느슨하게 유지할 수 있는 방법을 이용해 오직 추상화에만 의존하게 만든다.
- 이렇게 하면 변하지 않는 부분은 변하는 부분의 구체적인 종류에 대해서는 알지 못할 것이다.

## 정리
### 지속적으로 개선하라
- 협력을 설계하는 초기 단계에서 모든 요구사항을 미리 예상할 수는 없다. 새로운 요구사항을 수용할 수 있는 협력 패턴을 향해 설계를 진화시킬 수 있는 좋은 신호로 받아들여야 한다.
- 협력은 고정된 것이 아니다. 만약 현재의 협력패턴이 변경의 무게를 지탱하기 어렵다면 변경을 수용할 수 있는 협력 패턴을 향해 과감하게 리팩터링 하라

> **중요한것은 변경의 방향에 맞춰 지속적으로 코드를 개선하려는 의지**

### 패턴을 찾아라
- 핵심은 변경을 분리하고 캡슐화 하는것
- 유사한 기능에 대한 변경이 지속적으로 발생하고 있다면 변경을 캡슐화할 수 있는 적절한 추상화를 찾은 후, 추상화에 변하지 않는 공통적인 책임을 할당하라.
- 객체지향 설계는 객체의 행동과 그것을 지원하기 위한 구조를 계속 수정해 나가는 작업을 반복해 나가면서 다듬어 진다.
- 변경을 수용할 수 있는 적절한 역할과 책임을 찾다 보면 협력의 일관성이 서서히 윤곽을 드러낼 것이다.

## 느낀점
오브젝트 책을 읽으면서 객체지향의 핵심과 리펙터링의 목적을 가장 잘드러내는 파트가 아닐까라는 생각이 들었어요. 모든 요구사항을 미리 예상할 수는 없기에 새로운 요구사항이 생긴다면 그에따라 변하는 부분과 변하지 않는 부분이 드러날 것이고 이때 변화하는 부분을 캡슐화 하는 과정이 리팩터링이죠. 이렇게 리팩터링을 거듭해 나가다 보면 객체지향 설계에 가까워지는것 같아요.
